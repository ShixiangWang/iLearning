# 创建函数

*来源： Linux命令行与shell脚本编程大全*

**内容**

>- 基本的脚本函数
>- 返回值
>- 在函数中使用变量
>- 数组变量和函数
>- 函数递归
>- 创建库
>- 在命令行上使用函数



我们可以将shell脚本代码放进函数中封装起来，这样就能在脚本中的任何地方多次使用它了。

下面我们来逐步了解如何创建自己的shell脚本函数并在应用中使用它们。

## 基本的脚本函数

函数是一个脚本代码块，我们可以为其命名并在代码中任何位置重用。要在脚本中使用该代码块，只要使用所起的函数名就行了。

### 创建函数

有两种格式可以创建函数。第一种格式是使用关键字`function`，后跟分配给该代码块的函数名。

```shell
funtion name{
	commands
}
```

`name`属性定义了赋予函数的唯一名称，`commands`是构成函数的一条或多条bash shell命令。

第二种格式更接近其他编程语言中定义函数的方式：

```shell
name(){
  commands
}
```

### 使用函数

要使用函数，只需要像其他shell命令一样，在行中指定函数名就行了。

```shell
wsx@wsx:~/tmp$ cat test1
#!/bin/bash
# using a function in a script

function func1 {
    echo "This is an example of a function"
}

count=1
while [ $count -le 5 ]
do
  func1
  count=$[ $count + 1 ] 
done

echo "This is the end of the loop"
func1
echo "Now, this is the end of the script"

wsx@wsx:~/tmp$ ./test1
This is an example of a function
This is an example of a function
This is an example of a function
This is an example of a function
This is an example of a function
This is the end of the loop
This is an example of a function
Now, this is the end of the script
```

注意，定义函数名`func1`的后面一定要跟`{`有空格隔开，不然会报错。**函数要先定义再使用，接触过编程的想必不陌生吧**。

## 返回值

bash shell会把函数当做一个小型脚本，运行结束时会返回一个退出状态码，有3种不同的方法来为函数生成退出状态码。

### 默认退出状态码

默认函数的退出状态码是函数中最后一条命令返回的退出状态码。我们可以使用标准变量`$?`在函数执行结束后确定函数的状态码。

```shell
wsx@wsx:~/tmp$ cat test2
#!/bin/bash
# testing the exit status of a function

func1() {
	echo "trying to display a non-existent file"
	ls -l badfile
}

echo "testing the function"
func1
echo "The exit status is: $?"
wsx@wsx:~/tmp$ ./test2
testing the function
trying to display a non-existent file
ls: 无法访问'badfile': 没有那个文件或目录
The exit status is: 2
```

函数的退出状态码是2，说明函数的最后一条命令没有成功运行。但你无法知道函数中其他命令中是否成功运行，我们来看看下面一个例子。

```shell
wsx@wsx:~/tmp$ cat test3
#!/bin/bash
# testing the exit status of a function

func1(){
	ls -l badfile
	echo "This was a test of a bad command"
}

echo "testing the function:"
func1
echo "The exit status is: $?"
wsx@wsx:~/tmp$ ./test3
testing the function:
ls: 无法访问'badfile': 没有那个文件或目录
This was a test of a bad command
The exit status is: 0
```

这次函数的退出状态码是0，尽管其中有一条命令没有正常运行。可见使用函数的默认退出状态码是很危险的，幸运的是，我们有几种办法解决它。

### 使用return命令

`return`命令允许指定一个**整数值**来定义函数的退出状态码，从而提供了一种简单的途径来编码设定函数退出状态码。

```shell
wsx@wsx:~/tmp$ cat test4
#!/bin/bash
# using the return command in a function

function db1 {
	read -p "Enter a value: " value
	echo "doubling the value"
	return $[ $value * 2 ] 
}

db1
echo "The new value is $?"
wsx@wsx:~/tmp$ ./test4
Enter a value: 4
doubling the value
The new value is 8
```

当使用这种方法时要小心，记住下面两条技巧来避免问题：

- 函数一结束就取返回值
- 退出状态码必须是0~255

如果在用`$?`变量提取函数的返回值之前使用了其他命令，函数的返回值就会丢失。任何大于255的整数值都会产生一个错误值。

```shell
wsx@wsx:~/tmp$ ./test4
Enter a value: 200
doubling the value
The new value is 144
```

### 使用函数输出

如同可以将命令的输出保存到shell变量一样，我们也可以对函数的输出采用同样的处理办法。

```shell
result=`db1`
```

这个命令会将`db1`函数的输出赋值给`$result`变量。下面是脚本的一个实例：

```shell
wsx@wsx:~/tmp$ cat test4b
#!/bin/bash
# using the echo to return a value

function db1 {
	read -p "Enter a value: " value
	echo $[ $value * 2 ]
}

result=$(db1)
echo "The new value is $result"
wsx@wsx:~/tmp$ ./test4b
Enter a value: 200
The new value is 400
```

函数会用`echo`语句来显示计算的结果，该脚本会查看`db1`函数的输出，而不是查看退出状态码。

> 通过这种技术，我们还可以返回浮点值和字符串值，这使它成为一种获取函数返回值的强大方法。

 

## 在函数中使用变量

在函数中使用变量时，我们需要注意它们的定义方式以及处理方法。这是shell脚本常见错误的根源。

### 向函数传递参数

函数可以使用标准的参数环境变量来表示命令行上传给函数的参数。例如，函数名会在`$0`变量中定义，函数命令行上的任何参数都会通过`$1`、`$2`定义。也可以用特殊变量`$#`来判断给函数的参数数目。

指定函数时，必须将参数和函数放在同一行：

```shell
func1 $value1 10
```

然后函数可以用参数环境变量来获得参数值。下面是一个例子：

```shell
wsx@wsx:~/tmp$ cat test5
#!/bin/bash
# passing parameters to a function

function addem {
	if [ $# -eq 0 ] || [ $# -gt 2 ]
	then
		echo -1
	elif [ $# -eq 1 ]
	then
		echo $[ $1 + $1 ]
	else
		echo $[ $1 + $2 ]
	fi
}

echo -n "Adding 10 and 15: "
value=$(addem 10 15)
echo $value
echo -n "Let's try adding just one number: "
value=$(addem 10)
echo $value
echo -n "Now trying adding no numbers: "
value=$(addem)
echo $value
echo -n "Finally, try add three numbers: "
value=$(addem 10 15 20)
echo $value
wsx@wsx:~/tmp$ ./test5
Adding 10 and 15: 25
Let's try adding just one number: 20
Now trying adding no numbers: -1
Finally, try add three numbers: -1

```

`addem`函数首先会检查脚本传给它的参数数目。如果没有任何参数，或者参数多于两个，`addem`会返回`-1`。如果只有一个参数，`addem`会将参数与自身相加。如果有两个参数，`addem`会将它们相加。

**由于函数使用特殊参数环境变量作为自己的参数值，因此它无法直接获取脚本在命令行中的参数值。**下面是个失败的例子：

```shell
wsx@wsx:~/tmp$ cat badtest1 
#!/bin/bash
# trying to access script parameters inside a function

function badfunc1 {
	echo $[ $1 * $2 ]
}

if [ $# -eq 2 ]
then
	value=$(badfunc1)
	echo "The result is $value"
else
	echo "Usage: badtest1 a b"
fi

wsx@wsx:~/tmp$ ./badtest1 10 15
./badtest1: 行 5: *  : 语法错误: 需要操作数 (错误符号是 "*  ")
The result is 

```

尽管函数也使用了`$1`与`$2`变量，但它们与主脚本中的变量不同，要使用它们必须在调用函数时手动传入。

```shell
wsx@wsx:~/tmp$ cat test6
#!/bin/bash
# trying to access script parameters inside a function

function func1 {
	echo $[ $1 * $2 ]
}

if [ $# -eq 2 ]
then
	value=$(func1 $1 $2)
	echo "The result is $value"
else
	echo "Usage: badtest1 a b"
fi

wsx@wsx:~/tmp$ ./test6
Usage: badtest1 a b
wsx@wsx:~/tmp$ ./test6 10 15
The result is 150

```

### 在函数中处理变量

**作用域**是变量可见的区域。对脚本的其他部分而言，函数定义的变量是隐藏的。这些概念其实是编程语言中通用的，想必学过一些其他编程的朋友早已有所理解了。

函数使用两种类型的变量：

- 全局变量
- 局部变量

#### 全局变量

**全局变量**是在shell脚本中任何地方都有效的变量，如果你在函数内定义了一个全局变量，也可以在脚本的主体部分读取它的值。

默认情况下，我们在脚本中定义的任何变量都是全局变量。

```shell
wsx@wsx:~/tmp$ cat test7
#!/bin/bash
# using a global variable to pass a value

function db1 {
	value=$[ $value * 2 ] 
}

read -p "Enter a value: " value
db1
echo "The new value is: $value"

wsx@wsx:~/tmp$ ./test7
Enter a value: 10
The new value is: 20

```

无论变量在函数内外定义，在脚本中引用该变量都有效。这样其实非常危险，尤其是如果你想在不同的shell脚本中使用函数的话。它要求你清清楚楚地知道函数中具体使用了哪些变量，包括那些用来计算非返回值的变量。下面是一个如何搞砸的例子：

```shell
wsx@wsx:~/tmp$ cat badtest2
#!/bin/bash
# demonstrating a bad use of variable

function func1 {
	temp=$[ $value + 5 ]
	result=$[ $temp * 2 ]
}

temp=4
value=6

func1
echo "The result is $result"
if [ $temp -gt $value ]
then
	echo "temp is larger"
else
	echo "temp is smaller"
fi
wsx@wsx:~/tmp$ ./badtest2
The result is 22
temp is larger

```

由于函数中用到了`$temp`变量，它的值在脚本中使用时受到了影响，产生了意想不到的后果。后面我们会学习如何处理这样的问题。

#### 局部变量

无需在函数中使用全局变量，函数内部使用的任何变量都可以被声明成局部变量。**我们只需要在变量声明前加上local关键字就可以了**。

```shell
local temp
```

也可以在变量赋值时使用local关键字：

```shell
local temp=$[ $value + 5 ]
```

`local`关键字保证了变量只局限于该函数中。我们再回看刚才的例子：

```shell
wsx@wsx:~/tmp$ cat test8
#!/bin/bash
# demonstrating the local keyword

function func1 {
	local temp=$[ $value + 5 ]
	result=$[ $temp * 2 ]
}

temp=4
value=6

func1
echo "The result is $result"
if [ $temp -gt $value ]
then
	echo "temp is larger"
else
	echo "temp is smaller"
fi

wsx@wsx:~/tmp$ ./test8
The result is 22
temp is smaller

```



## 数组变量和函数

在函数中使用数组变量值有点麻烦，还需要一些特殊考虑。下面我们使用一种方法来解决问题。

### 向函数传数组参数

这个方法有点不好理解，将数组变量当做单个参数传递的话不起作用，下面我们看一个bad例子：

```shell
wsx@wsx:~/tmp$ cat badtest3
#!/bin/bash
# trying to pass an array variable

function testit {
	echo "The parameters are: $@"
	thisarray=$1
	echo "The received array is ${thisarray[*]}"
}

myarray=(1 2 3 4 5)
echo "The original array is: ${myarray[*]}"
testit $myarray
wsx@wsx:~/tmp$ ./badtest3
The original array is: 1 2 3 4 5
The parameters are: 1
The received array is 1
```

可以看到，当我们将数组变量当做函数参数传递时，函数只会取数组变量的第一个值。

针对这个问题，我们的一个解决方案是将数组变量全部拆分为单个值，然后作为参数传入函数，在函数内部又重新对这些值进行组装。

```shell
wsx@wsx:~/tmp$ cat test9
#!/bin/bash
# array variable to function test

function testit {
	local newarray
	newarray=(`echo "$@"`)
	echo "The new array value is: ${newarray[*]}"
}

myarray=(1 2 3 4 5)
echo ${myarray[*]}
testit ${myarray[*]}

wsx@wsx:~/tmp$ ./test9
1 2 3 4 5
The new array value is: 1 2 3 4 5

```



### 从函数中返回数组

采用与上面类似的方法，函数用`echo`语句来按正确顺序输出单个数组值，然后脚本再将它们重新放进一个新的数组变量中。

```shell
wsx@wsx:~/tmp$ cat test10
#!/bin/bash
# returning an array value

function arraydblr {
	local origarray
	local newarray
	local elements
	local i
	origarray=($(echo "$@"))
	newarray=($(echo "$@"))
	elements=$[ $# - 1 ]
	for (( i = 0; i <= $elements; i++ ))
	{
		newarray[$i]=$[ ${origarray[$i]} * 2]
	}
	echo ${newarray[*]}
}

myarray=(1 2 3 4 5)
echo "The orignal array is ${myarray[*]}"
arg1=$(echo ${myarray[*]})
result=($(arraydblr $arg1))
echo "The new array is: ${result[*]}"

wsx@wsx:~/tmp$ ./test10
The orignal array is 1 2 3 4 5
The new array is: 2 4 6 8 10

```

该脚本用`$arg1`变量将数组值传给`arraydblr`函数。该函数将数组重组到新的数组变量中，生成输出数组变量的一个副本，然后对数据元素进行遍历，将每个元素值翻倍，并将结果存入函数中该数组变量的副本。



## 函数递归

局部函数变量的一个特征是**自成体系**。这个特性使得函数可以递归地调用，也就是函数可以调用自己来得到结果。**通常递归函数都有一个最终可以迭代到的基准值。**

递归算法的经典例子是计算阶乘：一个数的阶乘是该数之前的所有数乘以该数的值。

比如5的阶乘：

```
5! = 1 * 2 * 3 * 4 * 5
```

方程可以简化为通用形式：

```
x! = x * (x-1)!
```

这可以用简单的递归脚本表达为：

```shell
function factorial {
  if [ $1 - eq 1 ]
  then
  	echo 1
  else
  	local temp=$[ $1 - 1 ]
  	local result=`factorial $temp`
  	echo $[ $result * $1 ]
  fi
}
```

