# 创建函数

*来源： Linux命令行与shell脚本编程大全*

**内容**

>- 基本的脚本函数
>- 返回值
>- 在函数中使用变量
>- 数组变量和函数
>- 函数递归
>- 创建库
>- 在命令行上使用函数



我们可以将shell脚本代码放进函数中封装起来，这样就能在脚本中的任何地方多次使用它了。

下面我们来逐步了解如何创建自己的shell脚本函数并在应用中使用它们。

## 基本的脚本函数

函数是一个脚本代码块，我们可以为其命名并在代码中任何位置重用。要在脚本中使用该代码块，只要使用所起的函数名就行了。

### 创建函数

有两种格式可以创建函数。第一种格式是使用关键字`function`，后跟分配给该代码块的函数名。

```shell
funtion name{
	commands
}
```

`name`属性定义了赋予函数的唯一名称，`commands`是构成函数的一条或多条bash shell命令。

第二种格式更接近其他编程语言中定义函数的方式：

```shell
name(){
  commands
}
```

### 使用函数

要使用函数，只需要像其他shell命令一样，在行中指定函数名就行了。

```shell
wsx@wsx:~/tmp$ cat test1
#!/bin/bash
# using a function in a script

function func1 {
    echo "This is an example of a function"
}

count=1
while [ $count -le 5 ]
do
  func1
  count=$[ $count + 1 ] 
done

echo "This is the end of the loop"
func1
echo "Now, this is the end of the script"

wsx@wsx:~/tmp$ ./test1
This is an example of a function
This is an example of a function
This is an example of a function
This is an example of a function
This is an example of a function
This is the end of the loop
This is an example of a function
Now, this is the end of the script
```

注意，定义函数名`func1`的后面一定要跟`{`有空格隔开，不然会报错。**函数要先定义再使用，接触过编程的想必不陌生吧**。

## 返回值

bash shell会把函数当做一个小型脚本，运行结束时会返回一个退出状态码，有3种不同的方法来为函数生成退出状态码。

### 默认退出状态码

默认函数的退出状态码是函数中最后一条命令返回的退出状态码。我们可以使用标准变量`$?`在函数执行结束后确定函数的状态码。

```shell
wsx@wsx:~/tmp$ cat test2
#!/bin/bash
# testing the exit status of a function

func1() {
	echo "trying to display a non-existent file"
	ls -l badfile
}

echo "testing the function"
func1
echo "The exit status is: $?"
wsx@wsx:~/tmp$ ./test2
testing the function
trying to display a non-existent file
ls: 无法访问'badfile': 没有那个文件或目录
The exit status is: 2
```

函数的退出状态码是2，说明函数的最后一条命令没有成功运行。但你无法知道函数中其他命令中是否成功运行，我们来看看下面一个例子。

```shell
wsx@wsx:~/tmp$ cat test3
#!/bin/bash
# testing the exit status of a function

func1(){
	ls -l badfile
	echo "This was a test of a bad command"
}

echo "testing the function:"
func1
echo "The exit status is: $?"
wsx@wsx:~/tmp$ ./test3
testing the function:
ls: 无法访问'badfile': 没有那个文件或目录
This was a test of a bad command
The exit status is: 0
```

这次函数的退出状态码是0，尽管其中有一条命令没有正常运行。可见使用函数的默认退出状态码是很危险的，幸运的是，我们有几种办法解决它。

### 使用return命令

`return`命令允许指定一个**整数值**来定义函数的退出状态码，从而提供了一种简单的途径来编码设定函数退出状态码。

```shell
wsx@wsx:~/tmp$ cat test4
#!/bin/bash
# using the return command in a function

function db1 {
	read -p "Enter a value: " value
	echo "doubling the value"
	return $[ $value * 2 ] 
}

db1
echo "The new value is $?"
wsx@wsx:~/tmp$ ./test4
Enter a value: 4
doubling the value
The new value is 8
```

当使用这种方法时要小心，记住下面两条技巧来避免问题：

- 函数一结束就取返回值
- 退出状态码必须是0~255

如果在用`$?`变量提取函数的返回值之前使用了其他命令，函数的返回值就会丢失。任何大于255的整数值都会产生一个错误值。

```shell
wsx@wsx:~/tmp$ ./test4
Enter a value: 200
doubling the value
The new value is 144
```

### 使用函数输出

如同可以将命令的输出保存到shell变量一样，我们也可以对函数的输出采用同样的处理办法。

```shell
result=`db1`
```

这个命令会将`db1`函数的输出赋值给`$result`变量。下面是脚本的一个实例：

```shell
wsx@wsx:~/tmp$ cat test4b
#!/bin/bash
# using the echo to return a value

function db1 {
	read -p "Enter a value: " value
	echo $[ $value * 2 ]
}

result=$(db1)
echo "The new value is $result"
wsx@wsx:~/tmp$ ./test4b
Enter a value: 200
The new value is 400
```

函数会用`echo`语句来显示计算的结果，该脚本会查看`db1`函数的输出，而不是查看退出状态码。

> 通过这种技术，我们还可以返回浮点值和字符串值，这使它成为一种获取函数返回值的强大方法。

 

## 在函数中使用变量

在函数中使用变量时，我们需要注意它们的定义方式以及处理方法。这是shell脚本常见错误的根源。

### 向函数传递参数

函数可以使用标准的参数环境变量来表示命令行上传给函数的参数。例如，函数名会在`$0`变量中定义，函数命令行上的任何参数都会通过`$1`、`$2`定义。也可以用特殊变量`$#`来判断给函数的参数数目。

指定函数时，必须将参数和函数放在同一行：

```shell
func1 $value1 10
```

然后函数可以用参数环境变量来获得参数值。下面是一个例子：

```shell
wsx@wsx:~/tmp$ cat test5
#!/bin/bash
# passing parameters to a function

function addem {
	if [ $# -eq 0 ] || [ $# -gt 2 ]
	then
		echo -1
	elif [ $# -eq 1 ]
	then
		echo $[ $1 + $1 ]
	else
		echo $[ $1 + $2 ]
	fi
}

echo -n "Adding 10 and 15: "
value=$(addem 10 15)
echo $value
echo -n "Let's try adding just one number: "
value=$(addem 10)
echo $value
echo -n "Now trying adding no numbers: "
value=$(addem)
echo $value
echo -n "Finally, try add three numbers: "
value=$(addem 10 15 20)
echo $value
wsx@wsx:~/tmp$ ./test5
Adding 10 and 15: 25
Let's try adding just one number: 20
Now trying adding no numbers: -1
Finally, try add three numbers: -1

```

`addem`函数首先会检查脚本传给它的参数数目。如果没有任何参数，或者参数多于两个，`addem`会返回`-1`。如果只有一个参数，`addem`会将参数与自身相加。如果有两个参数，`addem`会将它们相加。

**由于函数使用特殊参数环境变量作为自己的参数值，因此它无法直接获取脚本在命令行中的参数值。**下面是个失败的例子：

```shell
wsx@wsx:~/tmp$ cat badtest1 
#!/bin/bash
# trying to access script parameters inside a function

function badfunc1 {
	echo $[ $1 * $2 ]
}

if [ $# -eq 2 ]
then
	value=$(badfunc1)
	echo "The result is $value"
else
	echo "Usage: badtest1 a b"
fi

wsx@wsx:~/tmp$ ./badtest1 10 15
./badtest1: 行 5: *  : 语法错误: 需要操作数 (错误符号是 "*  ")
The result is 

```

尽管函数也使用了`$1`与`$2`变量，但它们与主脚本中的变量不同，要使用它们必须在调用函数时手动传入。

```shell
wsx@wsx:~/tmp$ cat test6
#!/bin/bash
# trying to access script parameters inside a function

function func1 {
	echo $[ $1 * $2 ]
}

if [ $# -eq 2 ]
then
	value=$(func1 $1 $2)
	echo "The result is $value"
else
	echo "Usage: badtest1 a b"
fi

wsx@wsx:~/tmp$ ./test6
Usage: badtest1 a b
wsx@wsx:~/tmp$ ./test6 10 15
The result is 150

```

### 在函数中处理变量

**作用域**是变量可见的区域。对脚本的其他部分而言，函数定义的变量是隐藏的。这些概念其实是编程语言中通用的，想必学过一些其他编程的朋友早已有所理解了。

函数使用两种类型的变量：

- 全局变量
- 局部变量

#### 全局变量



#### 局部变量