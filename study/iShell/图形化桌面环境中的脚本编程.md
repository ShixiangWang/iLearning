# 图形化桌面环境中的脚本编程

内容：

>- 创建文本菜单
>- 创建文本窗口部件
>- 添加X Window图形



## 创建文本菜单

创建交互式shell脚本最常用的方法是使用菜单，它提供了各种选项帮助脚本用户了解脚本能做到的和不能做的。

shell脚本菜单的核心是`case`命令，该命令会根据用户在菜单上的选择来执行特定命令。

下面我们逐步了解和创建基于菜单的shell脚本的步骤。

### 创建菜单布局

**第一步**是决定在菜单上显示哪些元素以及想要显示的布局方式。

**在创建菜单前，通常先清空显示器上已有的内容。这样能在干净的，没有干扰的环境中显示菜单了。**

`clear`命令使用当前终端的`terminfo`数据来清理出现在屏幕上的文字。运行`clear`命令后可以使用`echo`命令显示菜单元素。

**默认，echo命令只显示可打印的文本字符。**而在创建菜单时一些非文本字符也非常有用，比如制表符和换行符。我们需要添加`-e`选项使得`echo`命令能解析包含在其中的非文本字符。

例如，

```shell
wsx@wsx:~/tmp$ echo -e "1.\tDisplay disk space"
1.	Display disk space
```

这对于格式化菜单项布局非常方便，只需要几个`echo`命令就可以创建一个还不错的菜单。

```shell
clear
echo
echo -e "\t\t\tSys Admin Menu\n"
echo -e "\t1. Display disk space"
echo -e "\t2. Display logged on users"
echo -e "\t3. Display memory usage"
echo -e "\t0. Exit menu\n\n"
echo -en "\t\tEnter an option: "
```

最后一行`-en`选项去掉末尾换行符使得菜单更专业点，光标会在行尾等待用户输入。

**创建菜单的最后一步是获取用户输入。**这一步用`read`命令。因为我们只期望用户使用单字符输入，在命令加`-n`选项进行限定。这样用户只需要输入一个数字，不用摁回车键。

```shell
read -n 1 option
```



### 创建菜单函数

shell脚本菜单选项作为一组独立的函数实现起来更为容易。要做到这一点，你要为每个菜单项创建独立的shell函数。**第一步**是决定你希望脚本执行那些功能，然后将这些功能以函数的形式放在代码中。

**通常我们会为还没有实现的函数先创建一个*桩函数*，它是一个控函数，或者只有一个echo语句，说明最终这里需要什么内容。**

```shell
function diskspace {
  clear
  echo "This is where the diskspace commands will do"
}
```

这允许菜单在我实现某个函数时仍然能正常操作。不需要我们写出所有函数之后才能让菜单投入使用。函数从`clear`命令开始，这样我们就能在一个干净的屏幕上执行该函数，不会收到原先菜单的干扰。

**另外，将菜单布局本身作为一个函数来创建有利于菜单制作。**

```shell
function menu {
  	clear
	echo
	echo -e "\t\t\tSys Admin Menu\n"
	echo -e "\t1. Display disk space"
	echo -e "\t2. Display logged on users"
	echo -e "\t3. Display memory usage"
	echo -e "\t0. Exit menu\n\n"
	echo -en "\t\tEnter an option: "
	read -n 1 option
}
```

这样我们能在任何时候调用该函数以此重现菜单。

### 添加菜单逻辑

下一步我们需要创建程序逻辑将菜单布局和函数结合起来。这需要使用`case`命令。

`case`命令应该根据菜单中输入的字符来调用相应的函数，用case命令字符星号来处理所有不正确的菜单项。

下面展示了典型菜单的`case`用法：

```shell
menu
case $option in
0)
	break ;;
1) 
	diskspace ;;
2) 
	whoseon ;;
3) 
	memusage ;;
*)
	clear
	echo "Sorry, wrong selection";;
esac
```

这里首先调用`menu`函数清空屏幕并显示菜单。`menu`函数中的`read`命令会一直等待，知道用户在键盘上键入一个字符。然后`case`命令会接管余下的处理过程，基于字符调用相应的函数。

### 整合shell脚本菜单

现在让我们将前面的步骤全部组合起来，看看它们是如何协作的。

这是一个完整的菜单脚本例子：

```shell
wsx@wsx:~/tmp$ cat test14
#!/bin/bash
# simple script menu

function diskspace {
	clear
	df -k
}

function whoseon {
	clear
	who
}

function memusage {
	clear
	cat /proc/meminfo
}

function menu {
	clear
	echo
	echo -e "\t\t\tSys Admin Menu\n"
	echo -e "\t1. Display disk space"
	echo -e "\t2. Display logged on users"
	echo -e "\t3. Display memory usage"
	echo -e "\t0. Exit menu\n\n"
	echo -en "\t\tEnter an option: "
	read -n 1 option
}

while [ 1 ]
do
	menu
	case $option in
	0)
		break ;;
	1)
		diskspace ;;
	2)
		whoseon ;;
	3)
		memusage ;;
	*)
		clear
		echo "Sorry, wrong selection" ;;
	esac
	echo -en "\n\n\t\t\tHit any key to continue"
	read -n 1 line
done
clear

```

使用：

```shell
			Sys Admin Menu

	1. Display disk space
	2. Display logged on users
	3. Display memory usage
	0. Exit menu


		Enter an option: 
```

输入1：

```shell
文件系统           1K-块     已用      可用 已用% 挂载点
udev             4006080        0   4006080    0% /dev
tmpfs             807220    81004    726216   11% /run
/dev/sda4      305650672 14226064 275828680    5% /
tmpfs            4036100     1724   4034376    1% /dev/shm
tmpfs               5120        4      5116    1% /run/lock
tmpfs            4036100        0   4036100    0% /sys/fs/cgroup
/dev/sda3         524272     4684    519588    1% /boot/efi
tmpfs             807220       52    807168    1% /run/user/1000
tmpfs             807220       16    807204    1% /run/user/125
/dev/sda2      421886972 23340376 398546596    6% /media/wsx/存储


			Hit any key to continue
```

其他都可以自己测试一下，我就不赘言了。



### 使用select命令

`select`命令只需要一条命令就可以创建出菜单，然后获取输入的答案并自动处理。

命令格式如下：

```shell
select variable in list
do
	commands
done
```

**`list`参数是由空格分隔的文本选项列表，这些列表构成了整个菜单。**`select`命令会将每个列表项显示成一个带编号的选项，然后为选项显示一个由`PS3`环境变量定义的特殊提示符。

```shell
wsx@wsx:~/tmp$ cat smenu1 
#!/bin/bash
# using select in the menu

function diskspace {
	clear
	df -k
}

function whoseon {
	clear
	who
}

function memusage {
	clear
	cat /proc/meminfo
}

PS3="Enter an option: "
select option in "Display disk space" "Display logged on users" "Display memory usage" "Exit program"
do
	case $option in
	"Exit program")
		break ;;
	"Display disk space")
		diskspace ;;
	"Display logged on users")
		memusage ;;
	"Display memory usage"）
		memusage ;;
	*)
		clear
		echo "Sorry, wrong selection";;
	esac
done
clear

```

运行会自动生成如下菜单项：

```shell
wsx@wsx:~/tmp$ ./smenu1 
1) Display disk space	    3) Display memory usage
2) Display logged on users  4) Exit program
Enter an option:
```

**在使用`select`命令时，记住存储在变量中的结果值是整个文本字符串而不是跟菜单项相关联的数字。文本字符串是要在`case`语句中比较的内容。**



## 制作窗口

`dialog`包能够用ANSI转义控制字符在文本环境中创建标准的窗口对话框。我们可以将这些对话框融入自己的shell脚本中，借此与用户进行交互。这部分我们来学习如何使用`dialog`包。

安装：

```shell
sudo apt-get install dialog
```

### dialog包

`dialog`包使用命令行参数来决定生成哪种窗口部件（widget）。部件是dialog包中窗口元素的术语。

| 部件           | 描述                        |
| ------------ | ------------------------- |
| calendar     | 提供选择日期的日历                 |
| checklist    | 显示多个选项（其中每个选项都能打开或关闭）     |
| form         | 构建一个带有标签以及文本字段（可以填写内容）的表单 |
| fselect      | 提供一个文件选择窗口来浏览选择文件         |
| gauge        | 显示完成的百分比进度条               |
| infobox      | 显示一条消息，但不用等待回应            |
| inputbox     | 提供一个输入文本用的文本表单            |
| inputmenu    | 提供一个可编辑的菜单                |
| menu         | 显示可选择的一系列选项               |
| msgbox       | 显示一条消息，并要求用户选择OK按钮        |
| pause        | 显示一个进度条来显示暂定期间的状态         |
| passwordbox  | 显示一个文本框，但会隐藏输入的文本         |
| passwordform | 显示一个带标签的隐藏文本字段的表单         |
| radiolist    | 提供一组菜单选项，但只能选择其中一个        |
| tailbox      | 用tail命令在滚动窗口中显示文件的内容      |
| tailboxbg    | 跟tailbox一样，但是在后台模式中运行     |
| textbox      | 在滚动窗口中显示文件的内容             |
| timebox      | 提供一个选择小时、分钟和秒数的窗口         |
| yesno        | 提供一条带有Yes和No按钮的简单消息       |

如上表所见，我们可以选择很多不同的部件。只需要多花点功夫就可以让脚本看起来更专业。

**要在命令行上指定某个特定的部件，需要使用双破折线格式**：

```shell
dialog --widget parameters
```

其中`widget`是上表中某个特定的部件，`parameters`定义了部件窗口的大小以及部件需要的文本。

**每个dialog部件都提供了两种形式的输出：**

- 使用STDERR
- 使用退出状态码

可以通过`dialog`命令的退出状态码来确定用户选择的按钮。如果选择了Yes或OK按钮，命令会返回状态码`0`。如果选择了Cancer或No按钮，命令会返回状态码`1`。可用标准的`$?`变量来确定`dialog`部件具体选择了哪个按钮。

如果部件返回了数据，`dialog`命令会将数据发送到STDERR。我们可以用标准的bash shell方法将其重定向到另一个文件或文件描述符中。

```shell
dialog --inputbox "Enter your age:" 10 20 2>age.txt
```

这条命令将文本框输入的文本重定向到age.txt文本中。

